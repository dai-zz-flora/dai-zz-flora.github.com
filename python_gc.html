

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Python的垃圾回收机制 &mdash; 死程序员的摇滚生活</title>
    
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <link rel="top" title="死程序员的摇滚生活" href="index.html" />
    <link rel="prev" title="Tri-color marking 三色标记垃圾回收算法" href="tri_color_marking.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="tri_color_marking.html" title="Tri-color marking 三色标记垃圾回收算法"
             accesskey="P">上一页</a> |</li>
        <li><a href="index.html">死程序员的摇滚生活</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">內容目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">Python的垃圾回收机制</a><ul>
<li><a class="reference internal" href="#id1">1.关键技术</a></li>
<li><a class="reference internal" href="#id2">2.数据结构</a></li>
<li><a class="reference internal" href="#id3">3.流程</a><ul>
<li><a class="reference internal" href="#id4">3.1 对象创建</a></li>
<li><a class="reference internal" href="#id5">3.2 对象销毁</a></li>
<li><a class="reference internal" href="#id6">3.3 根据引用计数销毁</a></li>
<li><a class="reference internal" href="#id7">3.4 分代垃圾回收</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id8">4 细节注释</a><ul>
<li><a class="reference internal" href="#id9">4.1 如何找到根对象</a></li>
<li><a class="reference internal" href="#id10">4.2 标记并移动</a></li>
<li><a class="reference internal" href="#id11">4.3 如何进行代对象复制</a></li>
<li><a class="reference internal" href="#id12">4.3 线程安全</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id13">5.参考文档</a></li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="tri_color_marking.html"
                        title="上一章">Tri-color marking 三色标记垃圾回收算法</a></p>
<div id="searchbox" style="display: none">
  <h3>快速搜索</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="搜索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    输入相关的模块，术语，类或者函数名称进行搜索
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="python">
<h1>Python的垃圾回收机制<a class="headerlink" href="#python" title="永久链接至标题">¶</a></h1>
<div class="section" id="id1">
<h2>1.关键技术<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>Python包含一个比较轻量级的垃圾回收器，其主要代码分布gcmodule.c(主要负责分代垃圾回收)和obmalloc.c(主要负责引用计数垃圾回收)这两个文件中。几个主要关键的技术分别是</p>
<ul>
<li><p class="first"><strong>引用计数</strong></p>
<p>大多数对象的资源释放都通过引用计数来实现。当对象被引用(包括被设置为属性值、被添加到各式容器中等等)时，引用计数增长；当取消引用时，
引用计数减少；引用计数为0时，对象被释放。这里在python语言级别所用的引用，取消引用均由Python本身来完成；而在用C写扩展时，上述两种
操作由开发人员完成。</p>
</li>
<li><p class="first"><strong>标记清除</strong></p>
<p>大多数情况下，引用计数可以很好地工作，但考虑到可能存在下面这种代码，造成循环引用</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">if</span> <span class="n">something</span>
    <span class="n">l</span> <span class="o">=</span> <span class="p">[]</span> <span class="c"># l.ref_count = 1</span>
    <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="c"># l.ref_count = 2</span>
<span class="n">do</span> <span class="n">something</span><span class="p">;</span><span class="c"># l.ref_count = 1</span>
</pre></div>
</td></tr></table></div>
<p>因此引入标记清除的机制，标记即从根节点开始标记其直接或间接引用的子对象，清除即释放所有未被引用的对象</p>
</li>
<li><p class="first"><strong>分代垃圾回收</strong></p>
<p>分代垃圾回收是现代垃圾回收器的基本特性，主要思路是存活越久的对象，越少对其进行垃圾回收扫描，以便提高性能。而在Python中，
每代对象有一个数量阀值，超过该阀值则进行垃圾回收。</p>
</li>
<li><p class="first"><strong>对象链表</strong></p>
<p>在Python中，所有对象会被添加维护到对象链表中，每一代对象均由一个自己的链表来维护。</p>
</li>
</ul>
</div>
<div class="section" id="id2">
<h2>2.数据结构<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<ul>
<li><p class="first"><strong>python对象头引用计数</strong>:</p>
<p>每个PyObject对象都会包含一个PyObject_HEAD的结构，其在Python 2.7.3版本中的定义如下</p>
</li>
</ul>
<blockquote>
<div><div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* PyObject_HEAD defines the initial segment of every PyObject. */</span>
<span class="cp">#define PyObject_HEAD                   \</span>
<span class="cp">    _PyObject_HEAD_EXTRA                \</span>
<span class="cp">    Py_ssize_t ob_refcnt;               \</span>
<span class="cp">    struct _typeobject *ob_type;</span>
</pre></div>
</td></tr></table></div>
<p>其中 <cite>Py_ssize_t ob_refcnt</cite> 标示的被引用的次数</p>
</div></blockquote>
<ul>
<li><p class="first"><strong>可被垃圾回收对象结构</strong> :</p>
<p>当一个PyObject对象在其类型声明中指定了 <cite>Py_TPFLAGS_HAVE_GC</cite> 则该对象初始化时系统自动在对象内存空间之前分配一个 <cite>PyGC_Head</cite> 的结构</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">union</span> <span class="n">_gc_head</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="p">{</span>
        <span class="k">union</span> <span class="n">_gc_head</span> <span class="o">*</span><span class="n">gc_next</span><span class="p">;</span>
        <span class="k">union</span> <span class="n">_gc_head</span> <span class="o">*</span><span class="n">gc_prev</span><span class="p">;</span>
        <span class="n">Py_ssize_t</span> <span class="n">gc_refs</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">gc</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">double</span> <span class="n">dummy</span><span class="p">;</span>  <span class="cm">/* force worst-case alignment */</span>
<span class="p">}</span> <span class="n">PyGC_Head</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>其中 <cite>Py_ssize_t gc_refs;</cite> 会在之后的垃圾回收的标记中起到关键租用</p>
</li>
<li><p class="first"><strong>可被垃圾回收对象链表</strong> :</p>
<p>从上面 <cite>PyGC_Head</cite> 结构中可以看出，所有的可被垃圾回收对象由 <cite>gc_next</cite> 和 <cite>gc_head</cite> 链接起来，形成一个链表</p>
</li>
<li><p class="first"><strong>分代</strong> :</p>
<p>Python程序启动时会根据 <cite>NUM_GENERATIONS</cite> 分配若干代垃圾回收空间。每个空间均由一个可被回收对象链表组成。</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*** Global GC state ***/</span>

<span class="k">struct</span> <span class="n">gc_generation</span> <span class="p">{</span>
    <span class="n">PyGC_Head</span> <span class="n">head</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">threshold</span><span class="p">;</span> <span class="cm">/* collection threshold */</span>
    <span class="kt">int</span> <span class="n">count</span><span class="p">;</span> <span class="cm">/* count of allocations or collections of younger</span>
<span class="cm">                  generations */</span>
<span class="p">};</span>

<span class="cp">#define NUM_GENERATIONS 3</span>
<span class="cp">#define GEN_HEAD(n) (&amp;generations[n].head)</span>

<span class="cm">/* linked lists of container objects */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">gc_generation</span> <span class="n">generations</span><span class="p">[</span><span class="n">NUM_GENERATIONS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="cm">/* PyGC_Head,                               threshold,      count */</span>
    <span class="p">{{{</span><span class="n">GEN_HEAD</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">GEN_HEAD</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">}},</span>           <span class="mi">700</span><span class="p">,</span>            <span class="mi">0</span><span class="p">},</span>
    <span class="p">{{{</span><span class="n">GEN_HEAD</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">GEN_HEAD</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">}},</span>           <span class="mi">10</span><span class="p">,</span>             <span class="mi">0</span><span class="p">},</span>
    <span class="p">{{{</span><span class="n">GEN_HEAD</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">GEN_HEAD</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">}},</span>           <span class="mi">10</span><span class="p">,</span>             <span class="mi">0</span><span class="p">},</span>
<span class="p">};</span>

<span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">_PyGC_generation0</span> <span class="o">=</span> <span class="n">GEN_HEAD</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p>在上面的代码中 <cite>gc_generation</cite> 为分代的数据结构，其内容包含阀值( <cite>threshold</cite> ）和被回收的次数 ( <cite>count</cite> )。随后的全局初始化代码会自动
生成一个不跟随对象空间的 <cite>PyGC_Head</cite> 结构，其prev和next（通过调用 <cite>GEN_HEAD</cite> 宏）都指向自己，由此之后的插入都会使得该  链表成一个环状，
在今后的遍历中，以该头为开始，且以该头为结束。</p>
</li>
</ul>
</div>
<div class="section" id="id3">
<h2>3.流程<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<div class="section" id="id4">
<h3>3.1 对象创建<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><strong>说明</strong> : 在Python中，根据不同的情况有不同的函数来完成对象的创建工作，但大体流程均相似</li>
<li><strong>输入</strong> ：type:对象相应 <cite>PyTypeObject</cite> 类信息、nitems:容器大小（如果是容器对象的话）、args:初始化参数(<cite>PyObject *args, PyObject *kwds</cite>)</li>
<li><strong>输出</strong> : <cite>PyObject</cite> 对象指针</li>
<li><strong>方法</strong> ：</li>
</ul>
<blockquote>
<div><ul class="simple">
<li>1.根据 <cite>PyTypeObject</cite> 信息计算所需内存空间，申请内存空间，如果有必要的话，申请GC头。</li>
<li>2.根据 <cite>PyTypeObject</cite> 调用用户定义申请空间流程，并调用。</li>
<li>3.初始化通用属性值，包括引用计数。</li>
<li>4.调用 <cite>PyTypeObject</cite> 自定义的 <cite>init</cite> 函数，传入初始化参数，进行初始化。</li>
<li>5.加入GC链表</li>
<li>6.返回结果.</li>
</ul>
</div></blockquote>
<ul>
<li><p class="first"><strong>伪代码</strong>: 伪代码根据具体实现代码进行了抽象，部分流程与实际代码对比有差别，仅供参考</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">PyObject</span><span class="o">*</span> <span class="n">obj</span><span class="p">;</span>
<span class="cm">/*1.Get allocated size*/</span>
<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">_PyObject_VAR_SIZE</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">nitems</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">PyType_IS_GC</span><span class="p">(</span><span class="n">type</span><span class="p">))</span><span class="cm">/*是否需要垃圾回收*/</span>
   <span class="n">obj</span> <span class="o">=</span> <span class="n">_PyObject_GC_Malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
<span class="k">else</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">PyObject_MALLOC</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>

<span class="cm">/*2.Call custom defined new*/</span>
<span class="n">type</span><span class="o">-&gt;</span><span class="n">tp_new</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>

<span class="cm">/*3.Call PyObject_Init*/</span>
<span class="n">obj</span><span class="o">-&gt;</span><span class="n">obj_type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
<span class="n">obj</span><span class="o">-&gt;</span><span class="n">obj_refcnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="cm">/*4.call custom define init*/</span>
<span class="n">type</span><span class="o">-&gt;</span><span class="n">tp_init</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span><span class="n">args</span><span class="p">);</span>

<span class="cm">/*5.gc track*/</span>
<span class="k">if</span> <span class="p">(</span><span class="n">PyType_IS_GC</span><span class="p">(</span><span class="n">type</span><span class="p">))</span>
   <span class="n">_PyObject_GC_TRACK</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>

<span class="cm">/*6.return*/</span>
<span class="k">return</span> <span class="n">obj</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</li>
</ul>
</div>
<div class="section" id="id5">
<h3>3.2 对象销毁<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><strong>说明</strong> : 在Python中，根据不同的情况有不同的函数来完成对象的销毁工作，但大体流程均相似</li>
<li><strong>输入</strong> ：type:对象相应 <cite>PyTypeObject</cite> 类信息、obj:对象指针</li>
<li><strong>输出</strong> : 无</li>
<li><strong>方法</strong> ：</li>
</ul>
<blockquote>
<div><ul class="simple">
<li>1.根据 <cite>PyTypeObject</cite> 自定义方法，清除对属性对象的引用</li>
<li>2.从GC链表中删除自身</li>
<li>3.释放各种私有属性资源</li>
<li>4.释放对象</li>
</ul>
</div></blockquote>
<ul>
<li><p class="first"><strong>伪代码</strong>:</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*1.clear reference*/</span>
<span class="n">type</span><span class="o">-&gt;</span><span class="n">tp_clear</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>

<span class="cm">/*2.untrack*/</span>
<span class="k">if</span> <span class="p">(</span><span class="n">PyType_IS_GC</span><span class="p">(</span><span class="n">type</span><span class="p">))</span>
    <span class="n">_PyObject_GC_UNTRACK</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>

<span class="cm">/*3.free private resource*/</span>
<span class="n">free</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">private_fields</span><span class="p">);</span>

<span class="cm">/*4.free*/</span>
<span class="n">free</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
</li>
</ul>
</div>
<div class="section" id="id6">
<h3>3.3 根据引用计数销毁<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><strong>说明</strong> :对象在引用结束时显式调用Py_DECREF,Py_CLEAR等函数，当引用数为0时，会直接释放该对象(_Py_Dealloc)</li>
<li><strong>输入</strong> ：type:对象相应 <cite>PyTypeObject</cite> 类信息、obj:对象指针</li>
<li><strong>输出</strong> : 无</li>
<li><strong>方法</strong> ：</li>
</ul>
<blockquote>
<div><ul class="simple">
<li>1.引用计数减1</li>
<li>2.判断引用计数是否为0，为0则调用对象销毁方法</li>
</ul>
</div></blockquote>
<ul>
<li><p class="first"><strong>伪代码</strong>:</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">if</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">obj_refcnt</span><span class="o">--!=</span><span class="mi">0</span><span class="p">){</span>
   <span class="n">type</span><span class="o">-&gt;</span><span class="n">dealloc</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</li>
</ul>
</div>
<div class="section" id="id7">
<h3>3.4 分代垃圾回收<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><strong>说明</strong> : 如果存在循环引用等操作导致对象引用计数不为0，但是对象又不会被释放时，垃圾回收器才开始发挥作用</li>
<li><strong>输入</strong> ：generations:所有代</li>
<li><strong>输出</strong> : 无</li>
<li><strong>方法</strong> ：</li>
</ul>
<blockquote>
<div><ul class="simple">
<li>1.遍历所有代</li>
<li>2.判断本代对象数量是否超过阀值，如果超过则进行下列回收操作</li>
<li>3.合并本代所有比本代更年轻的代，</li>
<li>4.找到根节点</li>
<li>5.标记不可到达对象</li>
<li>6.将可到达对象加入到更老的代</li>
<li>7.清除不可到达对象</li>
</ul>
</div></blockquote>
<ul>
<li><p class="first"><strong>伪代码</strong>:</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">if</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">obj_refcnt</span><span class="o">--!=</span><span class="mi">0</span><span class="p">){</span>
   <span class="n">type</span><span class="o">-&gt;</span><span class="n">dealloc</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</li>
</ul>
</div>
</div>
<div class="section" id="id8">
<h2>4 细节注释<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<div class="section" id="id9">
<h3>4.1 如何找到根对象<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h3>
<p>从对象拷贝ref count
update_refs(young);
访问该代的每个节点对象直接引用的子对象，其引用数减1
subtract_refs</p>
</div>
<div class="section" id="id10">
<h3>4.2 标记并移动<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h3>
<p>遍历young list，两件事，如果ref_count不为0表明是root对象或者可reachable对象，标示为REACHABLE,将其直接引用的对象移动到young list末尾，并设置ref_count为1
如果ref_count为0，移动到unreachable,标示为可能UNREACHABLE，如果该对象是被root对象间接引用的会在其后的操作中重新被移动到young list中
move_unreachable</p>
</div>
<div class="section" id="id11">
<h3>4.3 如何进行代对象复制<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h3>
</div>
<div class="section" id="id12">
<h3>4.3 线程安全<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h3>
</div>
</div>
<div class="section" id="id13">
<h2>5.参考文档<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h2>
<ol class="arabic simple">
<li><a class="reference external" href="http://www.arctrix.com/nas/python/gc/">http://www.arctrix.com/nas/python/gc/</a></li>
</ol>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="tri_color_marking.html" title="Tri-color marking 三色标记垃圾回收算法"
             >上一页</a> |</li>
        <li><a href="index.html">死程序员的摇滚生活</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; 版权所有 2013, dai.zz.flora@gmail.com.
      使用 <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>